# Ассоциативный массив Long-Long
В исходных данных имеем: 
```
size    - общий объем выделенной памяти
address - адрес начала выделенной памяти
```
Исходя из требований о сложности О(1) при остутствии коллизий, было решено реализовать что-то вроде хэшмапы.
Выделенная область памяти разделяется на три области: 
- метаинформация (metaspace);
- индексированное пространство (indexed space) для хранения первого элемента бакета;
- неиндексированное пространство (linked space) для хранения коллизий.

### Метаинформация
Размер метаинформации - 16 байт. В метаиноформации находится:
```
8 байт - курсор, который указывает на первую свободную ячейку в неиндексированном пространстве (cursos) 
8 байт - размер индексированного пространства (indexedSpaceCapacity)
8 байт - адрес начала неиндексированного пространства (linkedSpaceAddress)
```
### Индексированное пространство
Размер индексированного пространства вычисляется динамически, LINKED_SPACE_MULTIPLIER указывает, насколько неиндексированное пространство должно быть больше индексированного.

```indexedSpaceSize = (size - METASPACE_SIZE) / (1 + LINKED_SPACE_MULTIPLIER)```

Размер индексированного пространства делится на размер записи, так мы получаем его емкость 

```indexedSpaceCapacity = indexedSpaceSize / 24```

### Неиндексированное пространство
Размер неиндексированного пространства занимает все оставшееся место.

```linkedSpaceSize = size - (metaspaceSize + indexedSpaceSize)```

Емкость неиндексированного пространства вычисляется аналогично:

```linkedSpaceCapacity = linkedSpaceSize / 24```

Адресс начала неиндексированного пространства:

```linkedSpaceAddress = address + METASPACE_SIZE + indexedSpaceCapacity * RECORD_SIZE```

Общая емкось нашего ассоциативного массива в итоге лежит в пределах:
```
1 + linkedSpaceCapacity <= overallCapacity <= indexedSpaceCapacity + linkedSpaceCapacity
```

### Формат записи
Запись состоит из трех полей по 8 байт. Итого 24 байта:
```
8 байт - Метаинформация
8 байт - Ключ 
8 байт - Значение
```
#### Метаинформация
```
1-62 биты (nextIdx)     - индекс следующей записи (recordAddress = initAddress + 24 * nextIdx).
63 бит (hasNext)         - флаг о наличии следующего значения в цепочке;
64 бит (hasValue)        - флаг о наличии значения в этой записи;
```